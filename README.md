# TestDataGen

[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

## Description

TestDataGen is a domain-specific language for generating intelligent test data. The language is created for the purpose of the Domain-Specific Languages course at the Faculty of Technical Sciences, University of Novi Sad.

Unlike traditional fake data generators that produce purely random values, TestDataGen implements **smart test data generation strategies** based on established software testing techniques:

- **Boundary Value Analysis (BVA)** - Automatically generates values at and around boundaries where defects are most likely to occur
- **Equivalence Partitioning (EP)** - Divides input domains into equivalence classes and generates representative values from each partition
- **Edge Case Generation** - Produces special values like `null`, empty strings, and invalid formats to test error handling

TestDataGen enables defining data schemas with constraints and relationships, then generates test datasets optimized for maximum code coverage and fault detection.

## Features

- **Declarative Schema Definition** - Define entities, types, constraints, and relationships in a clean, readable syntax
- **Smart Generation Strategies** - Choose between `random`, `boundary`, `partition`, or `smart` (combined) strategies at schema or field level
- **Combination Strategies** - Control how field values are combined using `full`, `pairwise`, or `each-used` algorithms to prevent combinatorial explosion
- **Built-in Data Types** - Support for common types: `uuid`, `email`, `fullName`, `date`, `number`, `boolean`, `enum`, and more
- **Entity Relationships** - Define references between entities with automatic foreign key generation
- **Edge Case Support** - Explicitly include `null`, `empty`, or `invalid` values for robustness testing
- **Custom Test Cases** - Define explicit test cases alongside auto-generated data for regression testing
- **Multiple Output Formats** - Generate SQL (PostgreSQL), JSON, and HTML Coverage Reports
- **Reproducible Results** - Seed-based generation for consistent, reproducible test datasets

## Example

This is an example of a test data schema defined using TestDataGen.

### Schema Example (`ecommerce.tdata`)

```
schema Ecommerce {
    
    description: "Test data for e-commerce application"
    seed: 12345
    strategy: smart
    combination_strategy: pairwise
    
    entity User {
        fields {
            id: uuid
            
            email: email {
                unique: true
                include: [null, empty, invalid]
            }
            
            age: number range 18-120 {
                boundary: true
                partitions: 3
            }
            
            status: enum ["active", "inactive", "banned"] {
                coverage: all
            }
            
            balance: number range 0-10000 {
                boundary: true
                partition: false
            }
            
            name: fullName {
                strategy: random
            }
            
            created_at: date range "2020-01-01" to "2025-12-31" {
                boundary: true
            }
        }
        
        config {
            generate: 50
            include: [
                { age: 42, email: "regression-bug-123@test.com", status: "banned", balance: 0 },
                { age: 18, email: null, status: "active", balance: 9999.99 }
            ]
        }
    }
    
    entity Product {
        fields {
            id: uuid
            name: productName
            
            price: number range 0.01-9999.99 {
                boundary: true
                precision: 2
            }
            
            stock: number range 0-1000 {
                boundary: true
                special: [0, 1, 999, 1000]
            }
            
            is_available: boolean {
                coverage: all
            }
        }
        
        config {
            generate: 100
            combination_strategy: full
        }
    }
    
    entity Order {
        fields {
            id: uuid
            user: ref User
            
            items: ref Product[] count 1-10 {
                boundary: true
            }
            
            total: number range 0.01-99999.99 {
                boundary: true
                precision: 2
            }
            
            status: enum ["pending", "processing", "shipped", "delivered", "cancelled"] {
                coverage: all
            }
        }
        
        config {
            generate: 200
        }
    }
}
```

### Generated SQL Example (`seed.sql`)

```sql
-- Generated by TestDataGen
-- Schema: Ecommerce
-- Strategy: smart (BVA + Equivalence Partitioning)
-- Combination Strategy: pairwise
-- Seed: 12345

-- Users table
INSERT INTO users (id, email, age, status, balance, name, created_at) VALUES
-- Boundary values for age (17, 18, 19, 119, 120, 121)
('a1b2c3d4-e5f6-7890-abcd-ef1234567890', 'john.doe@email.com', 18, 'active', 5000.00, 'John Doe', '2020-01-01'),
('b2c3d4e5-f6a7-8901-bcde-f12345678901', 'jane.smith@email.com', 19, 'inactive', 2500.00, 'Jane Smith', '2020-01-02'),
-- Edge cases for email (null, empty, invalid)
('c3d4e5f6-a7b8-9012-cdef-123456789012', NULL, 69, 'banned', 0.00, 'Bob Wilson', '2022-06-15'),
('d4e5f6a7-b8c9-0123-def0-234567890123', '', 119, 'active', 10000.00, 'Alice Brown', '2025-12-30'),
('e5f6a7b8-c9d0-1234-ef01-345678901234', 'invalid-email', 120, 'inactive', 0.01, 'Charlie Davis', '2025-12-31'),
-- Custom test cases from include section
('f6a7b8c9-d0e1-2345-0123-456789012345', 'regression-bug-123@test.com', 42, 'banned', 0, 'Test User 1', '2023-01-15'),
('a7b8c9d0-e1f2-3456-1234-567890123456', NULL, 18, 'active', 9999.99, 'Test User 2', '2023-06-20'),
-- ... more rows generated with pairwise combinations
;

-- Products table (using full combination strategy)
INSERT INTO products (id, name, price, stock, is_available) VALUES
('f6a7b8c9-d0e1-2345-f012-456789012345', 'Ergonomic Steel Chair', 0.01, 0, true),
('a7b8c9d0-e1f2-3456-0123-567890123456', 'Handmade Wooden Table', 9999.99, 1, false),
-- ... more rows
;

-- Orders table
INSERT INTO orders (id, user_id, total, status) VALUES
('b8c9d0e1-f2a3-4567-1234-678901234567', 'a1b2c3d4-e5f6-7890-abcd-ef1234567890', 0.01, 'pending'),
-- ... more rows
;

-- Order items (junction table)
INSERT INTO order_items (order_id, product_id) VALUES
('b8c9d0e1-f2a3-4567-1234-678901234567', 'f6a7b8c9-d0e1-2345-f012-456789012345'),
-- ... more rows
;
```

### Generated Coverage Report Example

The HTML coverage report shows which test cases were generated and calculates coverage as the percentage of **required test cases** that were actually generated (not the infinite input space).

| Entity | Field | Strategy | Required Cases | Generated | Coverage |
|--------|-------|----------|----------------|-----------|----------|
| User | age | BVA + EP | 9 (6 boundary + 3 partitions) | 9 | 100% |
| User | email | Edge Cases | 3 (null, empty, invalid) | 3 | 100% |
| User | status | All Values | 3 | 3 | 100% |
| User | balance | BVA only | 6 (boundary values) | 6 | 100% |
| Product | price | BVA | 6 | 6 | 100% |
| Order | items | BVA | 6 (count: 0, 1, 2, 9, 10, 11) | 6 | 100% |

**Note:** If `generate: N` is smaller than the number of required test cases, coverage will be less than 100% and the report will indicate how many additional records are needed for full coverage.

## Grammar

The TestDataGen language consists of two main parts:

1. **Schema Definition** - Metadata, global settings, and generation strategies
2. **Entity Declarations** - Define entities with fields, types, constraints, and relationships

### Schema-Level Options

| Option | Description | Default |
|--------|-------------|---------|
| `description` | Human-readable description of the schema | - |
| `seed` | Random seed for reproducible generation | Random |
| `strategy` | Default generation strategy for all fields | `random` |
| `combination_strategy` | How to combine field values (can be overridden per entity) | `pairwise` |

### Combination Strategies

Controls how values from different fields within an entity are combined. This is calculated **per entity separately** - entities do not affect each other's combinations.

| Strategy | Description | Use Case |
|----------|-------------|----------|
| `full` | Full Cartesian product of all field values | Small entities, exhaustive testing |
| `pairwise` | Every pair of values appears at least once | **Default** - good coverage with manageable size |
| `each-used` | Every value appears at least once | Minimal test set, smoke testing |

#### How to Calculate Each Strategy

**FULL (Cartesian Product):**
Multiply all field value counts.
- 2 fields (5 × 3): `5 × 3 = 15`
- 4 fields (5 × 3 × 2 × 4): `5 × 3 × 2 × 4 = 120`

**EACH-USED:**
Take the maximum of all field value counts.
- 2 fields (5 × 3): `max(5, 3) = 5`
- 4 fields (5 × 3 × 2 × 4): `max(5, 3, 2, 4) = 5`

**PAIRWISE:**
Ensure every pair of values from any two fields appears at least once. The minimum is determined by the largest pair.
- Approximation: `max(Ni × Nj)` for all field pairs i, j
- 2 fields (5 × 3): Only one pair type exists, so `5 × 3 = 15` (same as full!)
- 4 fields (5 × 3 × 2 × 4): Pairs are (5×3=15), (5×2=10), (5×4=20), (3×2=6), (3×4=12), (2×4=8). Minimum = `max(15,10,20,6,12,8) = 20`

#### Why Pairwise Works (4 Fields Example)

```
Field A: [a1, a2, a3, a4, a5]  → 5 values
Field B: [b1, b2, b3]          → 3 values
Field C: [c1, c2]              → 2 values
Field D: [d1, d2, d3, d4]      → 4 values
```

With 4 fields, one row covers 6 pairs simultaneously:
```
Row: { A: a1, B: b1, C: c1, D: d1 }

Covers:
- (a1, b1) ✓
- (a1, c1) ✓
- (a1, d1) ✓
- (b1, c1) ✓
- (b1, d1) ✓
- (c1, d1) ✓
```

Total pairs to cover: 15 + 10 + 20 + 6 + 12 + 8 = 71 pairs.
But each row covers 6 pairs, so we need approximately 71 ÷ 6 ≈ 12 rows minimum.
However, the (A, D) pair alone has 20 combinations, so we need at least 20 rows.

**Result: ~20-25 rows instead of 120 (full)**

#### Important: Pairwise = Full for 2 Fields

With only 2 fields, there's only one pair type. Each row covers exactly one pair, so pairwise offers no reduction:
- 2 fields (5 × 3): Pairwise = Full = 15

**Pairwise only provides benefits with 3+ fields.**

#### Comparison Table

| Fields | Values | FULL | PAIRWISE | EACH-USED |
|--------|--------|------|----------|-----------|
| 2 fields | 5 × 3 | 15 | 15 | 5 |
| 3 fields | 5 × 3 × 2 | 30 | ~15 | 5 |
| 4 fields | 5 × 3 × 2 × 4 | 120 | ~20-25 | 5 |
| 5 fields | 5 × 3 × 2 × 4 × 3 | 360 | ~20-25 | 5 |

**Note:** Pairwise drastically reduces combinations for 3+ fields while still guaranteeing every value pair is tested.

#### Entity-Level Override

Combination strategy can be set globally or overridden per entity:

```
schema Example {
    combination_strategy: pairwise    // Global default
    
    entity User {
        fields {
            age: number range 18-65
            status: enum ["active", "inactive"]
            role: enum ["admin", "user", "guest"]
        }
        
        config {
            generate: 20
            // Uses pairwise from schema default
        }
    }
    
    entity SimpleConfig {
        fields {
            enabled: boolean
            mode: enum ["fast", "slow"]
        }
        
        config {
            generate: 10
            combination_strategy: full    // Override: 2 × 2 = 4, full is fine
        }
    }
}
```

### Supported Data Types

| Type | Description | Example |
|------|-------------|---------|
| `uuid` | UUID v4 identifier | `a1b2c3d4-e5f6-7890-...` |
| `email` | Email address | `john.doe@email.com` |
| `fullName` | Full person name | `John Doe` |
| `firstName` | First name | `John` |
| `lastName` | Last name | `Doe` |
| `number` | Numeric value (with optional range) | `42`, `3.14` |
| `boolean` | Boolean value | `true`, `false` |
| `date` | Date (with optional range) | `2024-01-15` |
| `datetime` | Date and time | `2024-01-15T10:30:00` |
| `enum` | Enumerated value | `["active", "inactive"]` |
| `string` | Text (with optional length) | `Lorem ipsum...` |
| `productName` | Product name | `Ergonomic Steel Chair` |
| `companyName` | Company name | `Acme Corporation` |
| `address` | Street address | `123 Main St` |
| `city` | City name | `New York` |
| `country` | Country name | `United States` |
| `phone` | Phone number | `+1-555-123-4567` |
| `url` | URL | `https://example.com` |
| `ref` | Reference to another entity | `ref User` |

### Generation Strategies

Strategies can be set at schema level (global default) or overridden per field.

| Strategy | Description |
|----------|-------------|
| `random` | Pure random generation using Faker |
| `boundary` | Boundary Value Analysis - generates min, min+1, max-1, max, and invalid boundaries |
| `partition` | Equivalence Partitioning - divides range into classes and picks representatives |
| `smart` | Combines BVA + EP + Edge Cases for maximum coverage |

### Per-Field Strategy Override

Fields can override the global strategy or enable/disable specific sub-strategies:

```
schema Example {
    strategy: smart                    // Global: all sub-strategies enabled
    
    entity User {
        fields {
            // Uses global strategy (smart)
            age: number range 18-65
            
            // Override to random only (ignore smart)
            name: fullName {
                strategy: random
            }
            
            // Keep boundary, disable partition
            balance: number range 0-1000 {
                partition: false
            }
            
            // Enable boundary even if global was "random"
            score: number range 0-100 {
                boundary: true
            }
        }
        
        config {
            generate: 50
        }
    }
}
```

### Custom Test Cases (include)

Define explicit test cases that will always be generated, useful for regression testing:

```
entity User {
    fields {
        age: number range 18-65
        email: email
        status: enum ["active", "inactive", "banned"]
    }
    
    config {
        generate: 50
        
        // These records are ALWAYS generated (in addition to auto-generated ones)
        include: [
            { age: 42, email: "bug-123@test.com", status: "banned" },
            { age: 18, email: null, status: "active" }
        ]
    }
}
```

### Entity Structure

Each entity consists of two blocks:

| Block | Required | Description |
|-------|----------|-------------|
| `fields { }` | Yes | Field definitions (attributes with types and constraints) |
| `config { }` | No | Generation configuration (generate count, combination strategy, include) |

```
entity User {
    fields {
        // Field definitions go here
        id: uuid
        email: email { unique: true }
    }
    config {
        // Generation configuration goes here
        generate: 50
        combination_strategy: pairwise
        include: [...]
    }
}
```
This separation ensures clear distinction between entity schema (what the data looks like) and generation settings (how to generate it).

## Instructions

### Prerequisites

- Python 3.8+
- pip

### Installation

1. Clone the repository
```bash
git clone https://github.com/spasoje2001/testdatagen.git
cd testdatagen
```

2. Install dependencies
```bash
pip install -r requirements.txt
```

3. Install TestDataGen CLI
```bash
pip install -e .
```

### Usage

Generate test data from a schema file:

```bash
testdatagen generate ecommerce.tdata --output ./output --format sql,json,report
```

#### CLI Options

| Option | Description | Default |
|--------|-------------|---------|
| `--output`, `-o` | Output directory for generated files | Current directory |
| `--format`, `-f` | Output formats (comma-separated): `sql`, `json`, `report` | `sql` |
| `--seed`, `-s` | Override seed for reproducible generation | Schema seed or random |
| `--overwrite` | Overwrite existing files | `false` |

#### Examples

Generate only SQL:
```bash
testdatagen generate schema.tdata --format sql
```

Generate all formats with custom seed:
```bash
testdatagen generate schema.tdata --format sql,json,report --seed 42
```

Validate schema without generating:
```bash
testdatagen validate schema.tdata
```

## Project Structure

_To be added_

## Technologies Used

- **Python 3.8+** - Primary implementation language
- **[textX](https://github.com/textX/textX)** - DSL framework for grammar definition and parsing
- **[Faker](https://github.com/joke2k/faker)** - Realistic fake data generation
- **[Jinja2](https://jinja.palletsprojects.com/)** - Template engine for output generation


## Contributors

- [Spasoje Brborić](https://github.com/spasoje2001)
- [Luka Zelović](https://github.com/Zela11)
- [Milica Đumić](https://github.com/dumitka)
- [Luka Milanko](https://github.com/Lukaa01)

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
